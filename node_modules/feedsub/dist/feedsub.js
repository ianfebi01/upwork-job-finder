"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const feedme_1 = __importDefault(require("feedme"));
const newsemitter_1 = __importDefault(require("newsemitter"));
const miniget_1 = __importDefault(require("miniget"));
const zlib_1 = __importDefault(require("zlib"));
// Used for the skipdays tag.
const DAYS = ['sunday', 'monday', 'tuesday', 'wednesday',
    'thursday', 'friday', 'saturday'];
class FeedSub extends tiny_typed_emitter_1.TypedEmitter {
    /**
     * @constructor
     * @param {string} feed
     * @param {!Object} options
     */
    constructor(feed, options) {
        super();
        this.feed = feed;
        this.options = Object.assign({
            interval: 10,
            forceInterval: false,
            autoStart: false,
            emitOnStart: false,
            lastDate: null,
            history: [],
            maxHistory: 10,
            skipHours: false,
            hoursToSkip: null,
            skipDays: false,
            daysToSkip: null,
            requestOpts: {},
        }, options);
        // Create news emitter.
        this.news = new newsemitter_1.default({
            maxHistory: this.options.maxHistory,
            manageHistory: true,
            identifier: (item) => {
                let feedItem = item[0];
                return [
                    feedItem.title,
                    feedItem.link,
                    feedItem.pubdate,
                    feedItem.published,
                    feedItem.updated
                ].join(',');
            }
        });
        this.news.addHistory('item', this.options.history);
        this._first = this.news.history.get('item').size === 0;
        this.getOpts = Object.assign({
            headers: {},
            acceptEncoding: {
                gzip: () => zlib_1.default.createGunzip(),
                deflate: () => zlib_1.default.createInflate(),
            },
        }, this.options.requestOpts);
        if (this.options.autoStart) {
            this.start(true);
        }
    }
    /**
     * Start calling the read function on interval.
     *
     * @param {boolean} readOnStart
     */
    start(readOnStart) {
        this.stop();
        let ms = this.options.interval * 60000;
        this._intervalid = setInterval(this.read.bind(this), ms);
        if (readOnStart) {
            this.read();
        }
    }
    /**
     * Stop interval if any
     */
    stop() {
        clearInterval(this._intervalid);
    }
    /**
     * Reads feed and determines if there are any new items
     * emits new items through event `item`
     * if there are new items, emits `items` event at end with all items
     *
     * if callback is given, calls callback with all new items
     * even when there are 0.
     *
     * @param {!Function(!Error, Array.<Object>)} callback
     */
    read(callback) {
        let ended = false;
        let req;
        let items = [];
        let newItems = [];
        let sortOrder = 0;
        const error = (err) => {
            ended = true;
            this._first = false;
            if (typeof callback === 'function') {
                callback(err);
            }
            else {
                this.emit('error', err);
            }
            req.destroy();
        };
        const success = () => {
            if (ended) {
                return;
            }
            ended = true;
            if (sortOrder <= 0) {
                newItems.reverse();
            }
            this.news.addHistory('item', newItems.map((item) => [item]));
            if (this._first && !this.options.emitOnStart) {
                newItems = [];
            }
            newItems.forEach(item => this.emit('item', item));
            this.emit('items', newItems);
            if (req) {
                req.destroy();
            }
            if (typeof callback === 'function') {
                callback(null, newItems);
            }
        };
        // If skipHours or skipDays are enabled and feed provides hours/days
        // to skip and it's currently one of those hours/days, abort.
        const now = new Date();
        const shouldSkip = () => {
            return ((!this._first || !this.options.emitOnStart) &&
                (this.options.hoursToSkip || this.options.daysToSkip)) && ((this.options.hoursToSkip &&
                this.options.hoursToSkip.indexOf(now.getHours()) !== -1) ||
                (this.options.daysToSkip &&
                    this.options.daysToSkip.some((day) => {
                        return day.toLowerCase() === DAYS[now.getDay()];
                    })));
        };
        if (shouldSkip()) {
            return success();
        }
        req = miniget_1.default(this.feed, this.getOpts);
        req.on('response', (res) => {
            // Check if not modified code is sent back
            // in this case, the body will be empty.
            if (res.statusCode === 304) {
                return success();
            }
            // Check headers for conditional get.
            if (res.headers['last-modified']) {
                this.getOpts.headers['If-Modified-Since'] = res.headers['last-modified'];
            }
            if (res.headers.etag) {
                this.getOpts.headers['If-None-Match'] = res.headers.etag;
            }
            // Save date.
            let date;
            let getdate = (text) => date = text;
            // Create feed parser.
            const parser = new feedme_1.default();
            parser.on('error', error);
            // Try to get date from one of the fields.
            parser.once('pubdate', getdate);
            parser.once('lastbuilddate', getdate);
            parser.once('updated', getdate);
            // Change interval time if ttl available.
            if (!this.options.forceInterval) {
                parser.once('ttl', (minutes) => {
                    minutes = parseInt(minutes, 10);
                    // Only update if ttl is longer than requested interval.
                    if (minutes > this.options.interval) {
                        this.options.interval = minutes;
                        if (this.options.autoStart) {
                            this.start(false);
                        }
                    }
                });
            }
            // Listen for skipHours if enabled.
            if (this.options.skipHours && !this.options.hoursToSkip) {
                parser.once('skiphours', (data) => {
                    this.options.hoursToSkip =
                        [].concat(data.hour).map(h => parseInt(h, 10));
                });
            }
            // Listen for skipDays if enabled.
            if (this.options.skipDays !== false && !this.options.daysToSkip) {
                parser.once('skipdays', (data) => {
                    this.options.daysToSkip = [].concat(data.day);
                });
            }
            // Compare date when first item is encountered.
            const firstitem = (item) => {
                // If date is the same as last, abort.
                if (date && this.options.lastDate === date) {
                    return success();
                }
                if (shouldSkip()) {
                    return success();
                }
                // Continue if dates differ.
                if (date) {
                    this.options.lastDate = date;
                }
                parser.on('item', getItem);
                getItem(item);
            };
            parser.once('item', firstitem);
            const getItemDate = (item) => +new Date(item.pubdate || item.published || 0);
            const getItem = (item) => {
                if (sortOrder === 0) {
                    items.push(item);
                    sortOrder = getItemDate(item) - getItemDate(items[0]);
                    if (sortOrder < 0) {
                        items.forEach(getOlderItem);
                    }
                    else if (sortOrder > 0) {
                        items.forEach(getNewerItem);
                    }
                }
                else if (sortOrder < 0) {
                    getOlderItem(item);
                }
                else {
                    getNewerItem(item);
                }
            };
            const getOlderItem = (item) => {
                if (this._first) {
                    newItems.push(item);
                }
                else if (!ended) {
                    let emitted = this.news.emit('item', item);
                    if (emitted) {
                        newItems.push(item);
                    }
                    else {
                        // Check if this item has already been read in previous requests
                        // if it has, then stop parsing the rest of the document.
                        parser.removeListener('item', getItem);
                        success();
                    }
                }
            };
            let foundPrevItem = false;
            const getNewerItem = (item) => {
                if (this._first) {
                    newItems.push(item);
                }
                else if (!foundPrevItem && !this.news.emit('item', item)) {
                    foundPrevItem = true;
                }
                else if (foundPrevItem && this.news.emit('item', item)) {
                    newItems.push(item);
                }
            };
            req.pipe(parser);
            parser.on('finish', () => {
                if (ended) {
                    return;
                }
                // Process items in descending order if no order found at end.
                if (sortOrder === 0 && newItems.length === 0) {
                    items.forEach(getOlderItem);
                }
                success();
                this._first = false;
            });
        });
        req.on('error', error);
    }
}
exports.default = FeedSub;
module.exports = FeedSub;
//# sourceMappingURL=feedsub.js.map