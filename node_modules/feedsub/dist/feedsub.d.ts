import { TypedEmitter } from 'tiny-typed-emitter';
import { FeedItem } from 'feedme';
import NewsEmitter from 'newsemitter';
import miniget from 'miniget';
export interface Options {
    interval?: number;
    forceInterval?: boolean;
    autoStart?: boolean;
    emitOnStart?: boolean;
    lastDate?: null | string;
    history?: string[];
    maxHistory?: number;
    skipHours?: boolean;
    hoursToSkip?: number[];
    skipDays?: boolean;
    daysToSkip?: string[];
    requestOpts?: miniget.Options;
}
export declare type DefaultOptions = Required<Options>;
interface FeedSubEvents {
    'error': (err: Error) => void;
    'item': (item: FeedItem) => void;
    'items': (items: FeedItem[]) => void;
}
export { FeedItem } from 'feedme';
export default class FeedSub extends TypedEmitter<FeedSubEvents> {
    feed: string;
    options: DefaultOptions;
    news: NewsEmitter;
    getOpts: miniget.Options & {
        headers: Record<string, string>;
    };
    private _first;
    private _intervalid;
    /**
     * @constructor
     * @param {string} feed
     * @param {!Object} options
     */
    constructor(feed: string, options?: Options);
    /**
     * Start calling the read function on interval.
     *
     * @param {boolean} readOnStart
     */
    start(readOnStart?: boolean): void;
    /**
     * Stop interval if any
     */
    stop(): void;
    /**
     * Reads feed and determines if there are any new items
     * emits new items through event `item`
     * if there are new items, emits `items` event at end with all items
     *
     * if callback is given, calls callback with all new items
     * even when there are 0.
     *
     * @param {!Function(!Error, Array.<Object>)} callback
     */
    read(callback?: (err: null | Error, items?: FeedItem[]) => void): void;
}
